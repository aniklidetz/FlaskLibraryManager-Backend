Project Overview:
Implement a simple library management system with a Flask RESTful API and SQLAlchemy ORM, using an SQLite database. The system will manage books, customers, and loans.

1. Database Setup:
Create an SQLite database with three tables: Books, Customers, and Loans.
Books Table:
book_id (Primary Key, Auto-increment Integer)
name (String)
author (String)
year_published (Integer)
book_type (Integer: 1, 2, or 3)
is_active (Boolean, default True)
Customers Table:
customer_id (Primary Key, Auto-increment Integer)
name (String)
city (String)
age (Integer)
is_active (Boolean, default True)
Loans Table:
loan_id (Primary Key, Auto-increment Integer)
customer_id (Foreign Key to Customers.customer_id)
book_id (Foreign Key to Books.book_id)
loan_date (Date)
return_date (Date or NULL)
Define Book Types and Loan Durations:
Type 1: Up to 10 days loan
Type 2: Up to 5 days loan
Type 3: Up to 2 days loan

2. Data Access Layer (DAL):
Create SQLAlchemy Models for each table, including the is_active field in Books and Customers.
Define relationships between models where necessary.
Organize Code into Modules:
Create separate Python modules/files for each model/class.
Implement Unit Tests:
Write unit tests for CRUD operations on each model.
Use a testing framework like unittest or pytest.

3. Flask RESTful API:
Set Up Flask Application:
Initialize the Flask app and configure the SQLAlchemy database URI for SQLite.
Create API Endpoints for the following operations:
Books:
Add a new book
Endpoint: POST /books
Description: Adds a new book to the database.
Get all active books
Endpoint: GET /books
Description: Retrieves a list of all active books.
Find a book by name
Endpoint: GET /books/search?name=<name>
Description: Searches for books by name.
Deactivate a book (hide without deleting)
Endpoint: PUT /books/<book_id>/deactivate
Description: Sets the is_active field of the book to False.
Customers:
Add a new customer
Endpoint: POST /customers
Description: Adds a new customer to the database.
Get all active customers
Endpoint: GET /customers
Description: Retrieves a list of all active customers.
Find a customer by name
Endpoint: GET /customers/search?name=<name>
Description: Searches for customers by name.
Deactivate a customer (hide without deleting)
Endpoint: PUT /customers/<customer_id>/deactivate
Description: Sets the is_active field of the customer to False.
Loans:
Loan a book
Endpoint: POST /loans
Description: Creates a new loan record.
Return a book
Endpoint: PUT /loans/<loan_id>/return
Description: Sets the return_date for a loan.
Display all loans
Endpoint: GET /loans
Description: Retrieves all loan records.
Display late loans
Endpoint: GET /loans/late
Description: Retrieves loans that are overdue.


4. Client Application:
Front-End with Bootstrap:
Create a user interface using Bootstrap for styling.
Include at least three Bootstrap elements (e.g., navbar, forms, carousel).
Implement a carousel on the homepage to showcase featured books.
Pages to Implement:
Home Page:
Overview of the library system.
Books Page:
List and search active books.
Customers Page:
List and search active customers.
Loans Page:
View current and late loans.
About the Developer:
A resume page with the developer's information.

5. Sample Data Insertion:
Insert Sample Data into the Database for testing purposes.
Books Data:
Name
Author
Year Published
Type
To Kill a Mockingbird
Harper Lee
1960
1
1984
George Orwell
1949
2
The Great Gatsby
F. Scott Fitzgerald
1925
3
The Catcher in the Rye
J.D. Salinger
1951
1
Pride and Prejudice
Jane Austen
1813
2
The Hobbit
J.R.R. Tolkien
1937
3
Moby Dick
Herman Melville
1851
1
War and Peace
Leo Tolstoy
1869
2
Crime and Punishment
Fyodor Dostoevsky
1866
3
Brave New World
Aldous Huxley
1932
1
Anna Karenina
Leo Tolstoy
1877
2
Ulysses
James Joyce
1922
3
The Brothers Karamazov
Fyodor Dostoevsky
1880
1
The Grapes of Wrath
John Steinbeck
1939
2
Lord of the Flies
William Golding
1954
3
Jane Eyre
Charlotte Brontë
1847
1
Wuthering Heights
Emily Brontë
1847
2
Don Quixote
Miguel de Cervantes
1605
3
The Divine Comedy
Dante Alighieri
1320
1
The Odyssey
Homer
-800
2


Customers Data:
Name
City
Age
John Doe
New York
30
Emily Clark
Los Angeles
25
Michael Johnson
Chicago
40
Sophia Brown
Houston
35
James Wilson
Phoenix
28
Olivia Martin
Philadelphia
22
William Garcia
San Antonio
45
Isabella Anderson
San Diego
31
Henry Davis
Dallas
26
Amelia Rodriguez
San Jose
50
Alexander Lee
Austin
33
Mia Hernandez
Jacksonville
21
Ethan Martinez
Fort Worth
29
Charlotte White
Columbus
42
Lucas Thomas
San Francisco
34
Grace Thompson
Indianapolis
27
Liam Scott
Seattle
38
Ava Moore
Denver
24
Benjamin King
Washington D.C.
46
Harper Lewis
Boston
37


Loans Data:
Book ID
Customer ID
Loan Date
Return Date
1
5
2023-09-01
2023-09-08
3
1
2023-09-05
2023-09-10
2
7
2023-09-07
2023-09-09
4
6
2023-09-10
2023-09-15
5
8
2023-09-12
NULL
6
9
2023-09-14
NULL
7
2
2023-09-15
2023-09-18
8
10
2023-09-17
NULL
9
3
2023-09-19
NULL
10
4
2023-09-20
NULL
1
12
2023-09-02
2023-09-09
2
15
2023-09-06
NULL
3
13
2023-09-08
2023-09-11
4
20
2023-09-12
NULL
5
17
2023-09-14
2023-09-19
6
18
2023-09-16
NULL
7
14
2023-09-17
NULL
8
19
2023-09-18
2023-09-23
9
11
2023-09-20
NULL
10
16
2023-09-21
2023-09-28


Note: book_id and customer_id are auto-generated upon insertion into the Books and Customers tables.

6. Additional Requirements:
Automate Database Creation and Migration:
Use Flask-Migrate or SQLAlchemy's create_all() method to handle database migrations.
Documentation:
Provide clear documentation on how to set up and run the application.
Include instructions on how to populate the database with the sample data.
Testing:
Ensure all functionalities are tested and working as expected.
Test database connections thoroughly to resolve any connectivity issues.
Error Handling and Logging:
Implement comprehensive error handling and logging throughout the application.

7. Deactivation Logic:
Implement Deactivation Instead of Deletion:
For both books and customers, use the is_active field to control visibility without removing records from the database.
Update the relevant API endpoints to set is_active to False when deactivating a record.
Modify Retrieval Queries:
Update all queries for books and customers to include a filter for is_active = True.
python
Copy code
active_books = Book.query.filter_by(is_active=True).all()


Business Logic:
Ensure that deactivated books and customers are not involved in new loans.
Existing loans associated with deactivated books or customers should remain unaffected.
Optional Reactivation:
(Optional) Implement endpoints to reactivate books and customers by setting is_active back to True.

8. Business Logic Updates:
Loan Operations:
When creating a new loan, validate that both the book and customer are active.
Return appropriate error messages if attempting to loan a deactivated book or to a deactivated customer.
Return Operations:
Allow returns of books even if the book or customer has been deactivated, to maintain data integrity.
Front-End Adjustments:
Ensure that the user interface reflects the active status of books and customers.
Provide options to view deactivated records if necessary (e.g., for administrative users).

9. Client Application Enhancements:
Bootstrap Elements:
Use a navbar for site navigation.
Implement responsive forms for data entry.
Include a carousel on the home page for featured books.
User Experience:
Provide clear messages when actions are performed (e.g., "Book successfully deactivated").
Implement confirmation dialogs before deactivation.
Accessibility:
Ensure that the application is accessible and user-friendly.

10. Testing and Validation:
Unit Tests:
Write tests for all CRUD operations, including deactivation and reactivation.
Integration Tests:
Test the full workflow of loaning and returning books.
Edge Cases:
Test scenarios where a user attempts to loan a deactivated book or to a deactivated customer.
